# ADR-005: Gemini 负责推理决策，本地模型仅做 SFT

> **状态**: Proposed
> **创建时间**: 2026-01-28T22:30:00+08:00
> **前置文档**: ADR-001 ~ ADR-004
> **核心问题**: 是否可以让 Gemini API 承担 DPO 原本要优化的"决策能力"，本地只做 SFT？

---

## 1. 方案概述

### 1.1 原方案回顾

```
原方案 (ADR-003 v2):
┌─────────────────────────────────────────────────────────────┐
│  本地模型 (SFT + DPO)                                       │
│  ├── SFT: 学习 ReAct 格式                                   │
│  └── DPO: 优化关键决策 (工具选择、停止判断)                 │
│                                                             │
│  训练成本: SFT (~300 样本) + DPO (~500 样本)                │
│  推理: 本地模型做所有决策                                   │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 新方案提议

```
新方案:
┌─────────────────────────────────────────────────────────────┐
│  Gemini API (无需训练)                                      │
│  └── 负责: ReAct 推理、工具选择、停止判断                   │
│                                                             │
│  本地模型 (仅 SFT，可选)                                    │
│  └── 负责: 特定子任务 (如意图分类、实体提取)                │
│                                                             │
│  训练成本: 仅 SFT (可选)，无 DPO                            │
│  推理: Gemini 做核心决策，本地模型做辅助任务                │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 架构对比

### 2.1 原方案：本地模型主导

```
┌─────────────────────────────────────────────────────────────┐
│                    原方案架构                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  User Query                                                 │
│      │                                                      │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │        本地 ReAct Agent (SFT + DPO)                 │   │
│  │                                                     │   │
│  │  [Thought] ──▶ [Action] ──▶ [Observation] ──▶ ...  │   │
│  │        ▲              │                             │   │
│  │        │              ▼                             │   │
│  │        │      确定性检索工具                        │   │
│  │        │      (Qdrant, Neo4j)                       │   │
│  │        │              │                             │   │
│  │        └──────────────┘                             │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│      │                                                      │
│      ▼                                                      │
│  Gemini API (仅最终答案生成)                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘

训练需求: SFT + DPO
API 调用: 仅最终生成 (1 次/query)
```

### 2.2 新方案：Gemini 主导

```
┌─────────────────────────────────────────────────────────────┐
│                    新方案架构                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  User Query                                                 │
│      │                                                      │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           Gemini API (ReAct Agent)                  │   │
│  │                                                     │   │
│  │  [Thought] ──▶ [Action] ──▶ [Observation] ──▶ ...  │   │
│  │        ▲              │                             │   │
│  │        │              ▼                             │   │
│  │        │      确定性检索工具                        │   │
│  │        │      (Qdrant, Neo4j)                       │   │
│  │        │              │                             │   │
│  │        └──────────────┘                             │   │
│  │                                                     │   │
│  │  Prompt Engineering 替代 DPO                        │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│      │                                                      │
│      ▼                                                      │
│  Answer (Gemini 直接生成)                                   │
│                                                             │
│  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │
│  可选: 本地 SFT 模型                                        │
│  ├── 意图分类 (减少 API 调用)                               │
│  ├── 实体提取 (预处理)                                      │
│  └── 简单问题直接回答 (路由分流)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘

训练需求: 可选 SFT (辅助任务)
API 调用: 每轮 ReAct 都调用 (~3-5 次/query)
```

---

## 3. 职责分配

### 3.1 Gemini API 负责（核心推理）

| 任务 | 说明 | 替代方案 |
|------|------|----------|
| ReAct 推理 | Thought 生成 | Prompt Template |
| 工具选择 | 选择 T1-T5 | Few-shot Examples |
| 参数决策 | entity, chapter_range | In-context Learning |
| 停止判断 | 信息是否充分 | Prompt 指令 |
| 答案生成 | 综合检索结果 | 原本就用 Gemini |

### 3.2 本地 SFT 模型负责（可选辅助）

| 任务 | 是否需要 | 理由 |
|------|----------|------|
| 意图分类 | ⚠️ 可选 | 减少简单问题的 API 调用 |
| 实体提取 | ⚠️ 可选 | 预处理，提高检索质量 |
| 问题路由 | ⚠️ 可选 | 简单问题直接本地回答 |
| Query 改写 | ❌ 不需要 | Gemini 可以做 |
| 充分性判断 | ❌ 不需要 | Gemini 在 Thought 中做 |

### 3.3 完全不训练的极简方案

```
极简方案: 0 训练，纯 Prompt Engineering

User Query
    │
    ▼
Gemini API + ReAct Prompt + Few-shot Examples
    │
    ├── [Thought] Gemini 推理
    ├── [Action] Gemini 选择工具
    ├── [Observation] 确定性工具返回
    └── 循环直到 [Action] stop
    │
    ▼
Answer

训练成本: 0
Prompt 工程: 需要精心设计
```

---

## 4. 优劣分析

### 4.1 优势

| 优势 | 说明 |
|------|------|
| **零/低训练成本** | 无需 DPO 数据收集和训练 |
| **快速迭代** | 改 Prompt 即可调整行为，无需重新训练 |
| **利用 Gemini 强能力** | Gemini 的推理能力远超小模型 |
| **符合 RAG 理念** | 智能在 API，知识在外部存储 |
| **降低技术风险** | 避免 DPO 训练不收敛的风险 |
| **一致性** | 训练和推理用同一个模型 (Gemini) |

### 4.2 劣势

| 劣势 | 说明 | 缓解措施 |
|------|------|----------|
| **API 成本增加** | 每轮 ReAct 都调 API | 本地模型做路由分流 |
| **延迟增加** | 多次 API 往返 | 并行化、缓存 |
| **API 依赖** | 离线无法使用 | 可接受 (本就依赖 Gemini) |
| **定制化受限** | 无法针对特定模式优化 | Few-shot 示例补充 |
| **Prompt 工程复杂** | 需要精心设计 Prompt | 一次性投入 |

### 4.3 成本对比

| 维度 | 原方案 (SFT+DPO) | 新方案 (Gemini+可选SFT) |
|------|------------------|------------------------|
| **训练成本** | 高 (数据收集+训练) | 低/零 |
| **API 成本** | 低 (1次/query) | 高 (~3-5次/query) |
| **开发周期** | 长 (4-6周) | 短 (1-2周) |
| **技术风险** | 中 (DPO可能不收敛) | 低 |
| **可维护性** | 中 (需要重新训练) | 高 (改Prompt即可) |

### 4.4 API 成本估算

```
假设:
- 平均每个问题 4 轮 ReAct
- 每轮 ~500 tokens (input) + ~200 tokens (output)
- Gemini Pro 定价: $0.00025/1K input, $0.0005/1K output

每个问题成本:
- Input: 4 × 500 × $0.00025/1K = $0.0005
- Output: 4 × 200 × $0.0005/1K = $0.0004
- Total: ~$0.001/query

月度估算 (2000 queries):
- 约 $2/月 (在 GCP 学生免费额度内)
```

---

## 5. Prompt 设计

### 5.1 ReAct Prompt Template

```markdown
# Role
你是一个专业的检索决策 Agent。你的任务是通过多轮检索找到回答问题所需的信息。

# Available Tools
- vector_search(query, top_k, chapter_filter, entity_filter): 向量检索
- graph_search(entity, relation, depth): 图结构检索
- track_entity(entity, chapter_range): 实体时序追踪
- stop(): 结束检索，准备回答

# Rules
1. 每次只选择一个工具
2. 根据 Observation 决定下一步
3. 最多 5 轮检索
4. 信息充分时选择 stop()

# Output Format
[Thought] 你的分析
[Action] tool_name(params)

# Examples
<few-shot examples here>

# Current Task
Question: {question}
History: {history}
Last Observation: {observation}

请输出下一步:
```

### 5.2 Few-shot Examples 设计

```
Example 1: 简单事实查询
Q: "玛拉妮的性格是什么？"
[Thought] 这是简单的角色属性问题，单跳向量检索即可
[Action] vector_search(query="玛拉妮 性格", top_k=5)
[Observation] 找到：玛拉妮性格热情直率...
[Thought] 信息充分，可以回答
[Action] stop()

Example 2: 关系查询
Q: "A和B是什么关系？"
[Thought] 关系问题需要图检索
[Action] graph_search(entity="A", relation=None, depth=2)
...

Example 3: 时序演变 (展示多轮)
Q: "X事件如何发展？"
[Thought] 事件演变需要时序追踪
[Action] vector_search(query="X事件", top_k=5)
[Observation] 找到结局，但缺少起因
[Thought] 需要补充早期信息
[Action] track_entity(entity="X", chapter_range=(1, 3))
...
```

---

## 6. 混合架构（推荐）

### 6.1 分层设计

```
┌─────────────────────────────────────────────────────────────┐
│                    推荐混合架构                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  User Query                                                 │
│      │                                                      │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         本地 Router (SFT, 轻量)                      │   │
│  │                                                     │   │
│  │  判断问题复杂度:                                    │   │
│  │  - Simple → 直接向量检索 + Gemini 生成              │   │
│  │  - Complex → 进入 ReAct 流程                        │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│      │                                                      │
│      ├─── Simple (70%) ───▶ 单次检索 + Gemini 生成         │
│      │                      (1 API call)                   │
│      │                                                      │
│      └─── Complex (30%) ──▶ Gemini ReAct Agent             │
│                             (3-5 API calls)                │
│                                                             │
└─────────────────────────────────────────────────────────────┘

预期效果:
- 70% 问题: 1 次 API 调用
- 30% 问题: 3-5 次 API 调用
- 平均: ~1.9 次 API 调用/问题
```

### 6.2 本地 Router 的 SFT

```json
{
  "instruction": "判断问题复杂度",
  "input": "玛拉妮的性格是什么？",
  "output": "simple"
}

{
  "instruction": "判断问题复杂度",
  "input": "旅行者在纳塔的冒险经历是如何发展的？",
  "output": "complex"
}
```

**训练数据量**: ~200 样本
**模型规模**: 可用更小的模型 (1-3B)

---

## 7. 实施计划

### 7.1 Phase 1: 纯 Prompt 方案验证 (Week 1)

| 任务 | 交付物 |
|------|--------|
| 设计 ReAct Prompt | Prompt Template |
| 编写 Few-shot Examples | 10-15 个示例 |
| 实现工具调用接口 | Python 函数 |
| 端到端测试 | 测试报告 |

### 7.2 Phase 2: 评估与优化 (Week 2)

| 任务 | 交付物 |
|------|--------|
| 在评测集上测试 | 准确率报告 |
| 分析失败案例 | 错误分析文档 |
| 优化 Prompt | 改进版 Prompt |
| API 成本统计 | 成本报告 |

### 7.3 Phase 3: 可选本地 Router (Week 3, 如需)

| 触发条件 | 行动 |
|----------|------|
| API 成本过高 | 添加本地 Router 分流 |
| 简单问题效果好 | Router 路由简单问题到快速路径 |
| 复杂问题效果差 | 针对性优化 Prompt |

---

## 8. 与原方案对比

| 维度 | 原方案 (SFT+DPO) | 新方案 (Gemini+Prompt) |
|------|------------------|------------------------|
| 训练复杂度 | 高 | 低 |
| 数据需求 | 800+ 样本 | 0 (或 200 样本 Router) |
| 开发周期 | 6-8 周 | 2-3 周 |
| DPO 收敛风险 | 有 | 无 |
| API 成本 | 低 | 中 (可通过 Router 降低) |
| 可定制性 | 高 | 中 |
| 离线能力 | 有 | 无 |

---

## 9. 决策建议

### 9.1 推荐策略

```
Phase 1: 先用纯 Prompt 方案验证可行性 (0 训练)
    │
    ├─── 效果好 + 成本可接受 ───▶ 采用新方案，不做 DPO
    │
    └─── 效果不好 或 成本过高 ───▶ 考虑:
                                    ├─ 添加本地 Router (SFT)
                                    └─ 或回退到原方案 (SFT+DPO)
```

### 9.2 决策标准

| 指标 | 阈值 | 达标则采用新方案 |
|------|------|------------------|
| 端到端准确率 | ≥ 80% | ✓ |
| 平均 API 调用 | ≤ 3 次/问题 | ✓ |
| 月度 API 成本 | ≤ $10 | ✓ |
| 平均延迟 | ≤ 5 秒/问题 | ✓ |

---

## 10. 结论

| 问题 | 回答 |
|------|------|
| DPO 是否必要？ | **不一定**，Gemini 的推理能力可能足够 |
| 应该先做什么？ | **先验证纯 Prompt 方案** |
| 本地 SFT 的价值？ | **Router 分流**，降低 API 成本 |
| 风险是什么？ | API 成本和延迟，可通过 Router 缓解 |

**核心思路**:

> 不要过早优化。先用最简单的方案（Gemini + Prompt）验证可行性，
> 只有在证明不够用时，才逐步添加本地模型组件。

---

## 附录: ADR 系列总结

| ADR | 核心决策 | 状态 |
|-----|----------|------|
| 001 | 轻量级 DPO | 待重新评估 |
| 002 | DPO 优于 DAPO | 维持 (如果需要 DPO) |
| 003 | ReAct + Critical-step DPO | 待重新评估 |
| 004 | DPO 优先，GRPO 备选 | 待重新评估 |
| **005** | **Gemini 推理 + 可选 SFT Router** | **新提案** |
